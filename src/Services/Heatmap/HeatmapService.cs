using CSGO_Demos_Manager.Models;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Threading.Tasks;
using System.IO;
using System.Linq;
using CSGO_Demos_Manager.Exceptions.Heatmap;

namespace CSGO_Demos_Manager.Services.Heatmap
{
	public abstract class HeatmapService
	{
		public int SizeX { get; set; }

		public int SizeY { get; set; }

		public int StartX { get; set; }

		public int StartY { get; set; }

		public int EndX { get; set; }

		public int EndY { get; set; }

		public int ResX { get; set; }

		public int ResY { get; set; }

		public Image Overview { get; set; }

		public string OverviewImageData { get; set; }

		public static HeatmapService Factory(string name)
		{
			switch (name)
			{
				case "de_dust2":
					return new Dust2();
				case "de_inferno":
					return new Inferno();
				case "de_nuke":
					return new Nuke();
				case "de_cache":
					return new Cache();
				case "de_season":
					return new Season();
				case "de_cbble":
					return new Cbble();
				case "de_overpass":
					return new Overpass();
				case "de_mirage":
					return new Mirage();
				default:
					throw new MapHeatmapUnavailableException();
			}
		}

		public void CalcSize()
		{
			SizeX = EndX - StartX;
			SizeY = EndY - StartY;
		}

		/// <summary>
		/// Calcul X coordinate where the pixel will be draw on the image
		/// </summary>
		/// <param name="x"></param>
		private float CalculatePointToResolutionX(float x)
		{
			x += (StartX < 0) ? StartX * -1 : StartX;
			x = (float)Math.Floor((x / SizeX) * ResX);
			return x;
		}

		/// <summary>
		/// Calcul Y coordinate where the pixel will be draw on the image
		/// </summary>
		/// <param name="y"></param>
		private float CalculatePointToResolutionY(float y)
		{
			y += (StartY < 0) ? StartY * -1 : StartY;
			y = (float)Math.Floor((y / SizeY) * ResY);
			y = (y - ResY) * -1;
			return y;
		}

		/// <summary>
		/// Calculated X,Y coordinates
		/// </summary>
		/// <param name="points"></param>
		/// <returns></returns>
		private List<HeatmapPoint> GetCalculatedPoints(List<HeatmapPoint> points)
		{
			List<HeatmapPoint> heatmapPointsCalculated = new List<HeatmapPoint>();

			foreach (HeatmapPoint point in points)
			{
				// Calcul to resolution
				float x = CalculatePointToResolutionX(point.X);
				float y = CalculatePointToResolutionY(point.Y);

				point.X = x;
				point.Y = y;

				if(heatmapPointsCalculated.Contains(point))
				{
					var index = heatmapPointsCalculated.IndexOf(point);
					heatmapPointsCalculated[index].Value++;
				}
				else
				{
					heatmapPointsCalculated.Add(point);
				}
			}

			return heatmapPointsCalculated;
		}

		/// <summary>
		/// Generate a Image from its base 64 datas
		/// </summary>
		/// <param name="dataImage"></param>
		/// <returns></returns>
		private Image LoadImage(string dataImage)
		{
			// remove data:image/png;base64,
			dataImage = dataImage.Remove(0, 22);

			byte[] bytes = Convert.FromBase64String(dataImage);

			Image image;
			using (MemoryStream ms = new MemoryStream(bytes))
			{
				image = Image.FromStream(ms);
			}

			return image;
		}

		/// <summary>
		/// Merge overview image with canvas generated by Heatmap.js
		/// </summary>
		/// <param name="data"></param>
		/// <returns></returns>
		public Image GenerateImage(string data)
		{
			// Image with heatmap colors
			Image heatmapImage = LoadImage(data);

			// Final image
			Bitmap finalImage = new Bitmap(Overview.Width, Overview.Height);

			using (Graphics g = Graphics.FromImage(finalImage))
			{
				g.DrawImage(Overview, new Rectangle(0, 0, Overview.Width, Overview.Height));
				g.DrawImage(heatmapImage, new Rectangle(0, 0, heatmapImage.Width, heatmapImage.Height));
			}

			return finalImage;
		}

		public async Task<string> GenerateHtml(Demo demo, HeatmapSelector selector)
		{
			List<HeatmapPoint> heatmapPoints;
			int radius = 20;

			switch (selector.Id)
			{
				case "kills":
					heatmapPoints = new List<HeatmapPoint>(demo.Kills.Select(t => t.Point.Clone()).ToList());
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No kills occurs in this match");
					}
					break;
				case "shots":
					heatmapPoints = new List<HeatmapPoint>(demo.HeatmapPoints);
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No shots occurs during this match");
					}
					break;
				case "flashbangs":
					heatmapPoints = new List<HeatmapPoint>(demo.Rounds.SelectMany(r => r.FlashbangsExploded.Select(f => f.Point.Clone())).ToList());
					radius = 15;
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No flashbangs has been thrown during this match");
					}
					break;
				case "he":
					heatmapPoints = new List<HeatmapPoint>(demo.Rounds.SelectMany(r => r.ExplosiveGrenadesExploded.Select(f => f.Point.Clone())).ToList());
					radius = 15;
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No HE grenades has been thrown during this match");
					}
					break;
				case "smokes":
					heatmapPoints = new List<HeatmapPoint>(demo.Rounds.SelectMany(r => r.SmokesStarted.Select(f => f.Point.Clone())).ToList());
					radius = 15;
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No smokes has been thrown during this match");
					}
					break;
				case "molotovs":
					heatmapPoints = new List<HeatmapPoint>(demo.Rounds.SelectMany(r => r.MolotovsThrowed.Select(f => f.Point.Clone())).ToList());
					radius = 15;
					if (heatmapPoints.Count == 0)
					{
						throw new HeatmapDataNotFoundException("No molotovs has been thrown during this match");
					}
					break;
				default:
					return "";
			}

			string html = "";
			await Task.Run(() =>
			{
				List<HeatmapPoint> points = GetCalculatedPoints(heatmapPoints);

				string datas = "[";
				for (int i = 0; i < points.Count; i++)
				{
					datas += "{x: " + points[i].X + ",";
					datas += "y: " + points[i].Y + ",";
					datas += "value: " + points[i].Value;
					if (i == points.Count - 1)
					{
						datas += "}";
					}
					else
					{
						datas += "},";
					}

				}
				datas += "]";

				int max = points.Max(i => i.Value);

				string script = "function init(){var n=h337.create({container:document.getElementById(\"heatmapContainer\"),radius:" + radius + "}),d={max:" + max + ",data:" + datas + "};n.setData(d)}document.addEventListener(\"DOMContentLoaded\",init,!1);";

				html = string.Format(Properties.Resources.heatmap, script, OverviewImageData);
			});

			return html;
		}
	}
}